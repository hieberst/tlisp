% $Id$
%
% !TeX encoding = latin9
% !TeX program = pdfLaTeX+MakeIndex+BibTeX

\documentclass[11pt,a4paper,titlepage]{article}

\usepackage[ngerman]{babel}
\usepackage{bibgerm}
\usepackage[latin9]{inputenc}
\usepackage{makeidx}
	\makeindex
\usepackage{nomencl}
	\makenomenclature
\usepackage{graphicx}
\usepackage{ifpdf}
\usepackage{hyperref}
\usepackage{tikz}
	\usetikzlibrary{shapes,arrows}

\ifpdf
\hypersetup
{
	bookmarks=true,
	colorlinks=true,
	urlcolor=blue,
	pdfsubject={TinyLISP Version 1.0},
	pdftitle={TLISP},
	pdfauthor={Steffen Hieber},
	pdfpagemode=UseNone,
	pdfstartview=FitH,
	pdfstartpage=4
}
\fi

\addtolength\topmargin{-27pt}
\addtolength\textheight{68pt}

\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 2pt minus 1pt}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\newcommand{\uu}[1]{\underline{#1}}

\pagestyle{headings}

\title{TinyLISP Version 1.0}
\author{Steffen Hieber}
\date{November 1992 -- \today}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Vorwort}
Ich habe die erste Version von TLISP 1987 auf einem Commodore C128 entwickelt.
Das Betriebssystem war CP/M 3.0, die Forth-Version F83.

Mein damaliges Ziel, LISP zu erlernen, wurde mangels eines LISP-Interpreters
ein wenig erschwert, daher kam ich auf die Idee, mir einfach einen eigenen
LISP-Interpreter zu basteln. So entstand TLISP.

Da ich damals bei der Bundeswehr war, konnte ich nur an den Wochenenden ein
paar Stunden mit der Programmierung von TLISP verbringen.

Unmittelbar nach der Bundeswehr bin ich nach Erlangen gezogen, um an der
Friedrich-Alexander-Universit"at Erlangen-N"urnberg Informatik zu studieren.
Ich wei"s nicht, welcher Teufel mich geritten hat, aber kurz nach dem Umzug
nach Erlangen habe ich meinen Commodore C128 und alle CP/M-Disketten in die
M"ulltonne geworfen. Das war das Ende von TLISP.

In den n"achsten Jahren spukte mir immer wieder der Gedanke im Kopf herum,
TLISP neu zu programmieren, was ich dann auch des "ofteren ansatzweise
versucht habe. Ich war im Besitz einer DOS-Version von F83 und hatte auch
noch den generellen Aufbau der damaligen TLISP-Version im Kopf.

Irgendwie habe ich aber nie die n"otige Motivation dazu aufbringen k"onnen,
die Neuentwicklung von TLISP wirklich durchzuf"uhren.

Ich habe bereits mit dem Gedanken gespielt, TLISP in C oder C++ zu
programmieren, aber zumindest die Wiedergeburt von TLISP sollte in Forth
geschehen...

Jetzt ist es an der Zeit, TLISP unter Linux mit GNU Forth Version 0.3.0
neu zu entwickeln, wobei die Kompatibilit"at zu F83 gew"ahrleistet bleiben
soll.

\section{Einleitung}
TLISP ist ein einfacher, vollst"andig in Forth 83 geschriebener Interpreter
der Sprache LISP, wie ihn Prof.~Dr.~Dieter~M"uller~\cite{mu} beschreibt.

Dieses Skript ist kein Lehrbuch zu LISP oder Forth, die Lekt"ure von \cite{mu}
und \cite{ze} wird vorausgesetzt.

\section{Objektspeicher}\index{Objektspeicher}

\section{Funktionen}
\subsection{Referenz}

\subsubsection{GREATERP}\index{GREATERP}\label{GREATERP}
\begin{tabular}[ht]{lll}
\multicolumn{3}{l}{GREATERP {\it sexpr1 sexpr2}} \\
\multicolumn{3}{l}{Prüft, ob die Zahl {\it sexpr1} kleiner ist als
                   die Zahl {\it sexpr2}.} \\
Parameter:    & {\it sexpr1} & Die erste zu vergleichende Zahl. \\
              & {\it sexpr2} & Die zweite zu vergleichende Zahl. \\
Rückgabewert: & \multicolumn{2}{l}{T, wenn die Zahl {\it sexpr1} kleiner ist
                als die Zahl {\it sexpr2}, sonst NIL.} \\
Siehe auch:   & \multicolumn{2}{l}{\hyperref[LESSP]{LESSP}}
\end{tabular}

\subsubsection{LESSP}\index{LESSP}\label{LESSP}
\begin{tabular}[ht]{lll}
\multicolumn{3}{l}{LESSP {\it sexpr1 sexpr2}} \\
\multicolumn{3}{l}{Prüft, ob die Zahl {\it sexpr1} grösser ist als
                   die Zahl {\it sexpr2}.} \\
Parameter:    & {\it sexpr1} & Die erste zu vergleichende Zahl. \\
Parameter:    & {\it sexpr2} & Die zweite zu vergleichende Zahl. \\
Rückgabewert: & \multicolumn{2}{l}{T, wenn die Zahl {\it sexpr1} grösser ist
                als die Zahl {\it sexpr2}, sonst NIL.} \\
Siehe auch:   & \multicolumn{2}{l}{\hyperref[GREATERP]{GREATERP}}
\end{tabular}

\subsubsection{NUMBERP}\index{NUMBERP}\label{NUMBERP}
\begin{tabular}[ht]{lll}
\multicolumn{3}{l}{NUMBERP {\it sexpr}} \\
\multicolumn{3}{l}{Prüft, ob das Argument {\it sexpr} eine Zahl ist.} \\
Parameter:    & {\it sexpr} & das zu prüfende Argument. \\
Rückgabewert: & \multicolumn{2}{l}{T, wenn das Argument {\it sexpr} eine Zahl ist, sonst NIL.} \\
Siehe auch:   & \multicolumn{2}{l}{\hyperref[ZEROP]{ZEROP}}
\end{tabular}

\subsubsection{ZEROP}\index{ZEROP}\label{ZEROP}
\begin{tabular}[ht]{lll}
\multicolumn{3}{l}{ZEROP {\it sexpr}} \\
\multicolumn{3}{l}{Prüft, ob die Zahl {\it sexpr} die Zahl 0 ist.} \\
Parameter:    & {\it sexpr} & die zu prüfende Zahl. \\
Rückgabewert: & \multicolumn{2}{l}{T, wenn die Zahl {\it sexpr} die Zahl ist, sonst NIL.} \\
Siehe auch:   & \multicolumn{2}{l}{\hyperref[NUMBERP]{NUMBERP}}
\end{tabular}

%new-symbol TIMES      $fsubr ' times           ret-number 2 OR new-subr
%new-symbol TERPRI     $subr  ' terpri                     0    new-subr
%$t                    $subr  ' NOOP                       1    new-subr
%new-symbol SYMBOLP    $subr  ' symbolp         ret-bool   1 OR new-subr
%new-symbol SUB1       $subr  ' sub1            ret-number 1 OR new-subr
%new-symbol STRINGP    $subr  ' stringp         ret-bool   1 OR new-subr
%new-symbol SETQ       $fsubr ' setq                       2    new-subr
%new-symbol SET        $fsubr ' set                        2    new-subr
%new-symbol RPLACD     $subr  ' rplacd                     2    new-subr
%new-symbol RPLACA     $subr  ' rplaca                     2    new-subr
%new-symbol RETURN     $subr  ' prog-return                1    new-subr
%new-symbol RESET      $subr  ' reset                      0    new-subr
%new-symbol REMPROP    $subr  ' remprop         ret-bool   2 OR new-subr
%new-symbol REMAINDER  $subr  ' remainder       ret-number 2 OR new-subr
%new-symbol READ       $subr  ' read                       0    new-subr
%new-symbol QUOTIENT   $fsubr ' quotient        ret-number 2 OR new-subr
%$quote                $fsubr ' quote                      2    new-subr
%new-symbol PUTPROP    $subr  ' putprop                    3    new-subr
%new-symbol PROP       $fsubr ' prop                       2    new-subr
%new-symbol PROGN      $fsubr ' progn                      2    new-subr
%new-symbol PROG       $fsubr ' prog                       2    new-subr
%new-symbol PRINT      $subr  ' print                      1    new-subr
%new-symbol PRIN2      $subr  ' prin2                      1    new-subr
%new-symbol PRIN1      $subr  ' prin1                      1    new-subr
%new-symbol PRIN       $subr  ' prin                       1    new-subr
%new-symbol PLUS       $fsubr ' plus            ret-number 2 OR new-subr
%new-symbol PAIR       $subr  ' pair                       2    new-subr
%new-symbol OR         $fsubr ' l-or            ret-bool   2 OR new-subr
%new-symbol NULL       $subr  ' null            ret-bool   1 OR new-subr
%new-symbol NOT        $subr  ' null            ret-bool   1 OR new-subr
%nil                   $fsubr ' nilf            ret-bool   2 OR new-subr
%new-symbol MINUS      $subr  ' minus           ret-number 1 OR new-subr
%new-symbol MEMBER     $subr  ' member          ret-bool   2 OR new-subr
%new-symbol LOAD       $fsubr ' load            ret-bool   2 OR new-subr
%new-symbol LISTP      $subr  ' list?           ret-bool   1 OR new-subr
%new-symbol LIST       $fsubr ' evlis                      2    new-subr
%new-symbol LENGTH     $subr  ' length          ret-number 1 OR new-subr
%$lambda               $fsubr ' lambda                     2    new-subr
%new-symbol GO         $fsubr ' prog-go                    2    new-subr
%new-symbol GET        $subr  ' get                        2    new-subr
%new-symbol GENSYM     $subr  ' gensym                     0    new-subr
%$gc                   $subr  ' gc              ret-bool   0 OR new-subr
%new-symbol FUNCTION   $fsubr ' function                   2    new-subr
%new-symbol FREE       $subr  ' free            ret-bool   0 OR new-subr
%new-symbol EXIT       $subr  ' exitf                      0    new-subr
%$evalquote            $fsubr ' evalquote                  2    new-subr
%$eval                 $fsubr ' eval1                      2    new-subr
%new-symbol EQ         $subr  ' =               ret-bool   2 OR new-subr
%new-symbol DIFFERENCE $fsubr ' difference      ret-number 2 OR new-subr
%new-symbol CONS       $subr  ' cons                       2    new-subr
%new-symbol COND       $fsubr ' evcon                      2    new-subr
%new-symbol BIND       $subr  ' bind                       3    new-subr
%new-symbol ATOM       $subr  ' atom?           ret-bool   1 OR new-subr
%new-symbol ASSOC      $subr  ' assoc                      2    new-subr
%new-symbol APPLY      $subr  ' apply                      3    new-subr
%new-symbol APPEND     $subr  ' append                     2    new-subr
%new-symbol AND        $fsubr ' l-and           ret-bool   2 OR new-subr
%new-symbol ADD1       $subr  ' add1            ret-number 1 OR new-subr

\section{Internes}
\subsection{PRIN}
%\begin{figure}[h]
\tikzstyle{fc_terminal} = [draw, rounded rectangle,node distance=3cm, minimum width=3cm,minimum height=2em]
\tikzstyle{fc_data} = [draw, trapezium, inner xsep=0pt,trapezium left angle=70, trapezium right angle=110, node distance=3cm,minimum height=4em]
\tikzstyle{fc_branch} = [draw, diamond, shape aspect=2, text width=4.5em, node distance=3cm, inner sep=0pt]
\tikzstyle{fc_operational} = [draw, rectangle, minimum height=4em]
\tikzstyle{line} = [draw, -triangle 45]
\begin{tikzpicture}[node distance = 2cm, auto, align=center]
    \node [fc_terminal] (start) {Start};
    \node [fc_branch, below of=start] (is_atom) {atom?};
    \node [fc_operational, right of=is_atom, node distance=9cm] (print_atom) {Atom ausgeben \\ PRIN1};
    \node [fc_data, below of=is_atom] (print_car) {Ausgabe \\ "`("' und "`car"'};
    \node [fc_operational, below of=print_car, node distance=3cm] (next) {Berechnung \\ cdr(last())};
    \node [fc_branch, below of=next] (is_nil) {nil?};
    \node [fc_data, right of=is_nil, node distance=5cm] (print_dot) {Ausgabe "`."' \\};
    \node [fc_data, below of=print_dot] (print_cdr) {Ausgabe \\ "`cdr"' und "`)"'};
    \node [fc_terminal, below of=print_cdr] (end) {Ende};
    \path [line] (start) -- (is_atom);
    \path [line] (is_atom) -- node [near start]{Ja}  (print_atom);
    \path [line] (is_atom) -- node [near start]{Nein}(print_car);
    \path [line] (print_car) -- (next);
    \path [line] (next) -- (is_nil);
    \path [line] (is_nil) -- node [near start]{Nein}  (print_dot);
    \path [line] (is_nil) |- node [near start]{Ja}    (print_cdr);
    \path [line] (print_dot) -- (print_cdr);
    \path [line] (print_atom) |- (end);
    \path [line] (print_cdr) -- (end);
\end{tikzpicture}
%\caption{Flußdiagramm: PRIN}
%\end{figure}

\newpage
\section{Installation}
\subsection{Gforth}
\subsubsection{Android}
Sei \texttt{/storage/sdCard0} der interne Speicher und sei
\texttt{/storage/extSdCard/tlisp} das Installationsverzeichnis von TLISP.
\begin{enumerate}
\item Installation von Gforth aus Google Play Store und Ausführen von Gforth
      zum Entpacken des Quellcodes.
\item Kopieren der Dateien {\texttt tlisp.fs} und \texttt{*.lsp} nach
      \texttt{/storage/extSdCard/tlisp}
\item Erzeugen von \texttt{/storage/sdCard0/gforth/home/.gforthrc} mit
      folgendem Inhalt:
        \begin{verbatim}
        : tl    \ run tlisp on my android handy
            warnings off    \ 0. vs. #0.
            s" /storage/extSdCard/tlisp" set-dir drop
            s" tlisp.fs" required
            s" driver" evaluate
        ;
        \end{verbatim}
\end{enumerate}

\subsection{F83}
In F83 wird TLISP wie folgt ausgeführt:
\begin{verbatim}
open tfload.blk 2 load
open eaker.f83  tfload
open ans.f83    tfload
open tlisp.fs   tfload
driver
\end{verbatim}
Als Hilfe dazu gibt es diverse Helferlein:
\begin{itemize}
\item[tlisp.btm] Batch-Datei für 4DOS
\item[tlisp.ahk] AutoHotKey-Skript für Windows
\item[tlisp.sub] Submit-Datei für CP/M
\end{itemize}

Der Arbeitsspeicher ist in F83 wie folgt organisiert:
\begin{verbatim}
+------------------------------ limit
|
+------------------------------ first
|
+------------------------------ 54230 rp0 @
| return stack
+------------------------------ 54226 rp@
| terminal input buffer
+------------------------------ 54030 sp0 @ (tib)
| data stack
|------------------------------ 54029 sp@
| scratch area
+------------------------------ 24543 pad (here 80 +)
|
+------------------------------ 24463 dp @ (here)
| dictionary
+------------------------------
\end{verbatim}

\subsubsection{CP/M}
\begin{verbatim}
8080 Forth 83 Model
Version 2.1.0 Modified 01Jun84
\end{verbatim}
Auf Laufwerk B: befindet sich F83, Laufwerk C: TLISP.
\begin{verbatim}
c:
r ..\tlisp.sub l
submit tlisp ..\
\end{verbatim}

\subsubsection{DOS}
\begin{verbatim}
8086 Forth 83 Model
Version 2.1.0 Modified 01Jun84
\end{verbatim}

\subsection{F-PC}
\begin{verbatim}
d:
cd \work\src\tlisp
fload tlisp.seq
\end{verbatim}

\subsection{Win32Forth}
\begin{verbatim}
cd d:\work\src\tlisp
fload tlisp.f
driver
\end{verbatim}

\newpage
\section{Fragen}
\begin{enumerate}
\item Wie groß ist ein FCB? Warum hat B/FCB in F83 den Wert 42?
\item Warum dürfen Dateien unter DOS bei der BDOS-Funktion 15 (OPEN FILE)
      nicht schreibgeschützt sein?
\item Warum hat das ursprüngliche TFLOAD von R.~Zech auf dem C128 funktioniert?
\end{enumerate}

\newpage
\section{Offene Punkte}
\begin{enumerate}
\item Minimierung der Verwendung des Return-Stacks durch Vermeidung von
      Rekursion und des Worts {\texttt \textgreater R}; {\tt TESTS.LSP} muss
      unter F83 funktionieren.
      (Die aktuelle Ausnutzung nach Start liegt bei 38 Adressen, bei
      TESTS.LSP sogar bei 202 Adressen, siehe FREE)
\begin{verbatim}
      Status:       RECURSE         >R
                    -------         --
                    append          exec
                    (eval)          {mu/mod}
                    gc-walk         prog
                    pair            prog-go
                    prin            prog-return
                                    (read)
                                    >NUMBER
                                    OPEN-FILE
\end{verbatim}
\item Dokumentation inkl. Abweichungen von Müllers Buch (i.e. FUNCTION)
\end{enumerate}

% Tabellenverzeichnis
\newpage
\addcontentsline{toc}{section}{\listtablename}
\listoftables

% Abbildungsverzeichnis
\addcontentsline{toc}{section}{\listfigurename}
\listoffigures

% Abkürzungsverzeichnis
\nomenclature{CP/M}{\uu{C}ontrol \uu{P}rogram for \uu{M}icroprocessors}

\newpage
\renewcommand{\nomname}{Abkürzungsverzeichnis}
\addcontentsline{toc}{section}{\nomname}
\printnomenclature

% Literaturverzeichnis
\nocite{*}
\newpage
\addcontentsline{toc}{section}{\refname}
\bibliography{tlisp}
\bibliographystyle{gerplain}

% Stichwortverzeichnis
\newpage
\renewcommand{\indexname}{Stichwortverzeichnis}
\addcontentsline{toc}{section}{\indexname}
\printindex

\end{document}
